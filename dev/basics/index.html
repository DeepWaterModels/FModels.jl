<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code basics · DeepWaterModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DeepWaterModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Documentation</a></li><li class="current"><a class="toctext" href>Code basics</a><ul class="internal"><li><a class="toctext" href="#Abstract-types-1">Abstract types</a></li><li class="toplevel"><a class="toctext" href="#Donnee-initiale-1">Donnee initiale</a></li><li><a class="toctext" href="#Modele-1">Modele</a></li><li><a class="toctext" href="#Fonctions-1">Fonctions</a></li><li><a class="toctext" href="#Document-principal-(ce-que-voit-l&#39;utilisateur)-1">Document principal (ce que voit l&#39;utilisateur)</a></li><li><a class="toctext" href="#Le-solver-RK4-1">Le solver RK4</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Code basics</a></li></ul><a class="edit-page" href="https://github.com/WaterWavesModels/DeepWaterModels.jl/blob/master/docs/src/basics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Code basics</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Code-basics-1" href="#Code-basics-1">Code basics</a></h1><h2><a class="nav-anchor" id="Abstract-types-1" href="#Abstract-types-1">Abstract types</a></h2><ul><li><code>TimeSolver</code> (<code>RK4</code>, <code>Euler</code>, etc), </li><li><code>AbstractModel</code> (<code>Cheng</code>, <code>Matsuno</code>, etc), </li><li><code>InitialData</code> (<code>Bump</code>, <code>SolitaryWave</code>, etc)</li></ul><p>Instances are created from <code>Parameters</code> type.</p><pre><code class="language-none">Parameters</code></pre><p>Une structure <code>Problem</code>  représente un problème donné que l&#39;on va résoudre. Les données seront stockées dans data, qui est vide initialement.</p><pre><code class="language-none">Problem</code></pre><h1><a class="nav-anchor" id="Donnee-initiale-1" href="#Donnee-initiale-1">Donnee initiale</a></h1><pre><code class="language-julia">mutable struct Bump &lt;: InitialData  

    # est-ce utile que ce soit mutable ?
    # il faudrait forcer que toutes les InitialData (et pas seulement Bump) donnent h et u vecteurs réels

    h   :: Array{Float64,1}
    u   :: Array{Float64,1}

    function Bump(p :: Parameters) # Une donnée initiale est construite à partir de son nom et de la donnée de Parameters
    	mesh  = Mesh(-p.L, p.L, p.N)
    	h = exp.(-(mesh.x).^2)
    	u  = zeros(Complex{Float64}, mesh.N)
    	new(h,u)
    end
end</code></pre><h2><a class="nav-anchor" id="Modele-1" href="#Modele-1">Modele</a></h2><pre><code class="language-julia">mutable struct Matsuno &lt;: Model  

    # Données qui seront utilisées dans les fonctions init, build, fwave! (et fig pour label)
    label   :: String
    h       :: Array{Complex{Float64},1}
    u	      :: Array{Complex{Float64},1}
    Gamma   :: Array{Float64,1}
    Dx      :: Array{Complex{Float64},1}
    H       :: Array{Complex{Float64},1}
    Pi      :: BitArray{1}
    Px      :: FFTW.cFFTWPlan{Complex{Float64},-1,false,1}
    epsilon :: Float64
    hnew    :: Array{Complex{Float64},1}
    unew    :: Array{Complex{Float64},1}
    Int1    :: Array{Complex{Float64},1}
    Int2    :: Array{Complex{Float64},1}
    Int3    :: Array{Complex{Float64},1}

    function Matsuno(par::Parameters) # Un modèle est construit à partir de son nom et de la donnée de Parameters
        label = &quot;Matsuno&quot;
        mesh = Mesh(-par.L, par.L, par.N)
        Gamma = abs.(mesh.k)
        epsilon= par.epsilon
        Dx    =  1im * mesh.k            # Differentiation
        H     = -1im * sign.(mesh.k)     # Hilbert transform
        Pi    = Gamma .&lt; mesh.kmax * 2/3 # Dealiasing low-pass filter
        h0 = zeros(Complex{Float64}, par.N)
        Px  = plan_fft(h0; flags = FFTW.MEASURE)
        h, u, hnew, unew ,Int1, Int2, Int3 = similar(h0), similar(h0), similar(h0), similar(h0), similar(h0), similar(h0), similar(h0)
        new(label, h, u, Gamma, Dx, H, Pi, Px, epsilon, hnew, unew, Int1, Int2, Int3)
    end
end</code></pre><h2><a class="nav-anchor" id="Fonctions-1" href="#Fonctions-1">Fonctions</a></h2><p><code>init</code> et <code>build</code> pour le modèle Matsuno (c&#39;est le même pour Cheng)</p><p>Pour définir complètement un nouveau modèle, il faut définir la structure au dessus, les fonctions init et build au dessous, ainsi que la fonction <code>fwave</code> (que je n&#39;ai pas recopiée)</p><pre><code class="language-julia">function init(m :: Matsuno, data::InitialData)

         return (m.Pi.*fft(data.h),m.Pi.*fft(data.u))
end

function build(m :: Matsuno, h :: Array{Complex{Float64},1}, u :: Array{Complex{Float64},1})

         return InitialData(real(ifft(h)),real(ifft(u)))
end


function solve!(p::Problem)

    model = p.model( p.param )    # définit en particulier init et fwave! utilisés ci-dessous
  	(h,u) = init(model,p.initial) # La fonction init, définie pour chaque modèle ransforme la donnée initiale
  	solver = p.solver( p.param.N )

  	times = Times(p.param.dt, p.param.T)
  	prog = Progress(times.Nt,1) # progress bar

    push!(p.data,(h,u))

    for l in range(1,times.Nt-1)

        step!( solver, model, fwave!, h, u, p.param.dt)   # la fonction step ne change pas par rapport aux versions précédentes
        push!( p.data, (h,u))   

        next!(prog)
    end

end</code></pre><h2><a class="nav-anchor" id="Document-principal-(ce-que-voit-l&#39;utilisateur)-1" href="#Document-principal-(ce-que-voit-l&#39;utilisateur)-1">Document principal (ce que voit l&#39;utilisateur)</a></h2><pre><code class="language-julia">epsilon = 1/2
N       = 2^12
L       = 10
T       = 5
dt      = 0.001

param = Parameters(epsilon,N,L,T,dt)

problems = [Problem(Cheng,Bump,param,RK4),Problem(Matsuno,Bump,param,RK4)]</code></pre><p>Cheng est le modèle utilisé. Il prend en valeur Bump, param et définit 3 fonction</p><ol><li><code>init</code> qui construit une donnée initiale à partir de Bump : Uinit=init(Bump,param)</li><li><code>Fwave</code> utilisée pour résoudre dt U= Fwave(U) (avec donnée initiale Uinit)</li><li><code>build</code> qui reconstruit la donnée finale (c&#39;est l&#39;application inverse de init). Ufin=final(U,param)</li></ol><p>Bump est la donnée initiale, on pourrait stocker des exemples pertinents dans un dossier à part (comme pour les modèles et les solvers)</p><p>param doit être défini par l&#39;utilisateur : c&#39;est grâce à lui que l&#39;on reconstruit mesh, time, etc. dans les différentes fonctions.</p><p>Il pourrait changer entre deux simulation  :</p><pre><code class="language-julia">simuls = [(Cheng,Bump,param1,RK4),(Cheng,Bump,param2,RK4)]</code></pre><h2><a class="nav-anchor" id="Le-solver-RK4-1" href="#Le-solver-RK4-1">Le solver RK4</a></h2><p>ne change pas par rapport aux versions précédentes. Il n&#39;a besoin que de param.N en argument (on pourrait par souci de cohérence lui donner carrément param en argument)</p><pre><code class="language-julia">for p in problems
    solve!(p)
end</code></pre><p>Le résultat de la simulation est stocké dans p.data pour chaque élément de problems il faut ensuite faire un fig pour plotter les solutions (c&#39;est là que la fonction build des modèles sera utile)</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Documentation</span></a></footer></article></body></html>
