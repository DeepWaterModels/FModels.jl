var documenterSearchIndex = {"docs":
[{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"EditURL = \"https://github.com/WaterWavesModels/ShallowWaterModels.jl/blob/master/examples/two_problems.jl\"","category":"page"},{"location":"examples/two_problems/#Two-water-problems-1","page":"Example","title":"Two water problems","text":"","category":"section"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"#using ShallowWaterModels\ninclude(\"../src/dependencies.jl\")","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"param = ( μ  = 1/20,\n          ϵ  = 1/2,\n          N  = 2^11,\n          L  = 20,\n          T  = 15,\n          dt = 0.001,\n          θ = 2,\n\t\t  α = 1/2,\n\t\t  a=-1/3,\n\t\t  b=1/3)\n\ninit = Bellcurve(param)\n\nmodel1 = Matsuno(param)\nsolver1 = RK4(param,model1)\nproblem1 = Problem(model1, init, param; solver = solver1);\n\nmodel2 = Matsuno_naive(param)\nsolver2 = RK4(param,model2)\nproblem2 = Problem(model2, init, param; solver = solver2);\nnothing #hide","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"p = plot(layout=(2,1))\n\nproblems = [ problem1, problem2 ]\n\nfor problem in problems\n\tprint(\"\\nNow solving the model \",problem.model.label,\"\\n\")\n   \t@time solve!( problem )\n   \tfig_problem!( p, problem )\n\nend","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"savefig(\"two_problems.pdf\")","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"","category":"page"},{"location":"examples/two_problems/#","page":"Example","title":"Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contents/#Contents-1","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"contents/#","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"contents/#Index-1","page":"Contents","title":"Index","text":"","category":"section"},{"location":"contents/#","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"basics/#Code-basics-1","page":"Code basics","title":"Code basics","text":"","category":"section"},{"location":"basics/#Abstract-types-1","page":"Code basics","title":"Abstract types","text":"","category":"section"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"TimeSolver (RK4, Euler, etc), \nAbstractModel (Cheng, Matsuno, etc), \nInitialData (Bump, SolitaryWave, etc)","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Instances are created from Parameters type.","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Parameters","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Une structure Problem  représente un problème donné que l'on va résoudre. Les données seront stockées dans data, qui est vide initialement.","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Problem","category":"page"},{"location":"basics/#ShallowWaterModels.Problem","page":"Code basics","title":"ShallowWaterModels.Problem","text":"Problem( model, initial, param; solver)\n\nBuilds an initial-value problem which can then be solved (integrated in time) through solve!( problem )\n\nArguments\n\nmodel   :: AbstractModel,  the system of equation solved. May be built, e.g., by WhithamGreenNaghdi(param);\ninitial :: InitialData, the initial data. May be buit, e.g., by Init(η,v) where η is the surface deformation and v the derivative of the trace of the velocity potential at the surface\nparam   :: NamedTuple, must contain values for\nN, the number of collocation points of the spatial grid\nL, the half-length of the spatial grid\nT, the final time of integration\ndt, the timestep\nnr (optional, default = T/dt) the number of stored data\nsolver  :: TimeSolver (optional, default = explicit Runge-Kutta fourth order solver), the solver for time integration. May be built, e.g., by RK4(param) or RK4_naive()\n\n\n\n\n\n","category":"type"},{"location":"basics/#Initial-data-1","page":"Code basics","title":"Initial data","text":"","category":"section"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Bump","category":"page"},{"location":"basics/#Shallow-water-models-1","page":"Code basics","title":"Shallow water models","text":"","category":"section"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Cheng","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Matsuno","category":"page"},{"location":"basics/#ShallowWaterModels.Matsuno","page":"Code basics","title":"ShallowWaterModels.Matsuno","text":"Matsuno(params)\n\n\n\n\n\n","category":"type"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"solve!(::Problem)","category":"page"},{"location":"basics/#ShallowWaterModels.solve!-Tuple{Problem}","page":"Code basics","title":"ShallowWaterModels.solve!","text":"solve!( problem )\n\nSolves (i.e. integrates in time) an initial-value problem\n\nThe argument problem should be of type :: Problem. It may be buit, e.g., by Problem(model, initial, param)\n\n\n\n\n\n","category":"method"},{"location":"basics/#Main-program-1","page":"Code basics","title":"Main program","text":"","category":"section"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"epsilon = 1/2\nN       = 2^12\nL       = 10\nT       = 5\ndt      = 0.001\n\nparam = Parameters(epsilon,N,L,T,dt)\n\nproblems = [Problem(Cheng,Bump,param,RK4),Problem(Matsuno,Bump,param,RK4)]","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"Cheng est le modèle utilisé. Il prend en valeur Bump, param et définit 3 fonction:","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"init qui construit une donnée initiale à partir de Bump : Uinit=init(Bump,param)\nFwave utilisée pour résoudre dt U= Fwave(U) (avec donnée initiale Uinit)\nbuild qui reconstruit la donnée finale (c'est l'application inverse de init). Ufin=final(U,param)","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"init(::Cheng)\ninit(::Matsuno)","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"build(::Cheng)\nbuild(::Matsuno)","category":"page"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"simuls = [(Cheng,Bump,param1,RK4),(Cheng,Bump,param2,RK4)]","category":"page"},{"location":"basics/#RK4-solver-1","page":"Code basics","title":"RK4 solver","text":"","category":"section"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"RK4","category":"page"},{"location":"basics/#ShallowWaterModels.RK4","page":"Code basics","title":"ShallowWaterModels.RK4","text":"`RK4(param,model;k)`\n\nConstructs an object of type `TimeSolver` to be used in `Problem(model, initial, param; solver::TimeSolver)`\n\nparam ::NamedTuple should contain a value N (number of collocation points)\nmodel ::AbstractModel is optional and determines the number of equations solved\nk=2   ::Int is optional (default = 2) and determines the number of equations solved\n\n\n\n\n\n","category":"type"},{"location":"basics/#","page":"Code basics","title":"Code basics","text":"for p in problems\n    solve!(p)\nend","category":"page"},{"location":"#ShallowWaterModels.jl-1","page":"Documentation","title":"ShallowWaterModels.jl","text":"","category":"section"},{"location":"#","page":"Documentation","title":"Documentation","text":"Modules = [ShallowWaterModels]\nOrder   = [:type, :function]","category":"page"},{"location":"#ShallowWaterModels.BellCurve","page":"Documentation","title":"ShallowWaterModels.BellCurve","text":"BellCurve(param)\nparam should contain a value theta\n\neta = 2^(-x^theta)\n\nv = 0\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Boussinesq","page":"Documentation","title":"ShallowWaterModels.Boussinesq","text":"Boussinesq(params)\nparams must contain two parameters a and b.\nThis computes the abcd Boussinesq model with d=b and c=0. You need a+2*b=1/3 for validity as a long wave model.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.CGBSW","page":"Documentation","title":"ShallowWaterModels.CGBSW","text":"CGBSW( params )\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.CGBSW_naive","page":"Documentation","title":"ShallowWaterModels.CGBSW_naive","text":"CGBSW_naive( params )\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Data","page":"Documentation","title":"ShallowWaterModels.Data","text":"Data structure to store the solution of the problem along time\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.HighFreq","page":"Documentation","title":"ShallowWaterModels.HighFreq","text":"HighFreq(param)\nparam should contain s (regularity index) and freq (frequencies)\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Init","page":"Documentation","title":"ShallowWaterModels.Init","text":"Init(data)\ndata should contain either\n- a function η and a function v (in this order)\n- a Namedtuple with a function η and a function v\n- a mesh and two vectors Vector{Complex{Float64}} or Vector{Float64} representing η(mesh.x) and v(mesh.x) (in this order)\n- a mesh and a Namedtuple with a vector η and a vector v as above\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Matsuno_mod_naive","page":"Documentation","title":"ShallowWaterModels.Matsuno_mod_naive","text":"Modified Matsuno models with a naive step function\nMatsuno_mod_naive(params)\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Matsuno_naive","page":"Documentation","title":"ShallowWaterModels.Matsuno_naive","text":"Matsuno(params)\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Mesh","page":"Documentation","title":"ShallowWaterModels.Mesh","text":"`Mesh(args)`\n\nConstructs a mesh of collocation points and associated Fourier modes.\n\nArguments\n\nCan be either\n\nxmin :: Float64, xmax :: Float64, N :: Int64;\nL :: Float64, N :: Int64, same as above with xmin=-L and xmax=L;\nparam :: NamedTuple, param contains N and L, then same as above.\n\nThe mesh as N collocation points regularly spaced between xmin (included) and xmax (excluded)\n\nReturn values\n\nm=Mesh(args) is of parametric type and offers with\n\nm.N: number of collocation points and Fourier modes;\nm.xmin: minimum of the mesh;\nm.xmax: maximum of the mesh;\nm.dx: distance between two collocation points;\nm.x: the vector of collocation points;\nm.kmin: minimum of Fourier modes;\nm.kmax: maximum of Fourier modes;\nm.dk: distance between two Fourier modes;\nm.k: the vector of Fourier modes.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.PseudoSpectral","page":"Documentation","title":"ShallowWaterModels.PseudoSpectral","text":"PseudoSpectral(param;kwargs)\n\nDefines an object of type AbstractModel in view of solving the initial-value problem for the modified water waves expansion proposed by West et al., Craig-Sulem, etc.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nE.g. param = ( μ  = 0.1, ϵ  = 1, N  = 2^9, L  = 10*π)\n\nKeywords\n\norder :: Int: the order of the expansion; linear system if 1, quadratic if 2, cubic if 3, quartic if 4 (default and other values yield 2);\nlowpass :: Real: applies a low-pass filter on frequencies above lowpass (default is 0, i.e. no low-pass filter);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing).\n\nReturn values\n\nThis generates\n\na function PseudoSpectral to be called in the time-integration solver;\na function mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed.\na function mapfro which from such raw data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is a tangential surface velocity (the derivative of the trace of the velocity potential at the surface).\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.RK4_naive","page":"Documentation","title":"ShallowWaterModels.RK4_naive","text":"`RK4_naive()`\n\nRunge-Kutta fourth order solver. Constructs an object of type TimeSolver to be used in `Problem(model, initial, param; solver::TimeSolver)\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Random","page":"Documentation","title":"ShallowWaterModels.Random","text":"Random(param)\n\nparam should contain s (regularity index)\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.Times","page":"Documentation","title":"ShallowWaterModels.Times","text":"`Times(dt, tfin; ns = 1)`\n\nConstructs a mesh of times.\n\nArguments\n\ndt  : timestep;\ntfin: final time;\nns  : data are stored every nr computations (optional, default = 1).\n\nReturn values\n\nt=Times(args) is of parametric type and offers\n\nt.Nc: number of computed times;\nt.Ns: number of recorded (stored) times;\nt.ns: data are stored every ns computations;\nt.tfin: the final time;\nt.dt: the timestep;\nt.tc : the vector of computed times;\nt.ts: the vector of recorded times.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.WaterWaves","page":"Documentation","title":"ShallowWaterModels.WaterWaves","text":"WaterWaves(params)\nThe Water Waves system, through conformal mapping\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.WhithamGreenNaghdi","page":"Documentation","title":"ShallowWaterModels.WhithamGreenNaghdi","text":"WhithamGreenNaghdi(param;kwargs)\n\nDefines an object of type AbstractModel in view of solving the initial-value problem for the modified Green-Naghdi model proposed by V. Duchêne, S. Israwi and R. Talhouk.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nE.g. param = ( μ  = 0.1, ϵ  = 1, N  = 2^9, L  = 10*π)\n\nKeywords\n\nSGN :: Bool: if true computes the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (default is false);\niterative :: Bool: solves the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond :: Bool: Preconditioner of GMRES is based on WGN if true, SGN otherwise (default is true);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-14);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing).\n\nReturn values\n\nThis generates\n\na function WhithamGreenNaghdi to be called in the time-integration solver;\na function mapto which from (η,v) of type InitialData provides the  data matrix on which computations are to be executed.\na function mapfro which from such data matrix returns the Tuple of real vectors (η,v,u), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.WhithamGreenNaghdiGPU","page":"Documentation","title":"ShallowWaterModels.WhithamGreenNaghdiGPU","text":"WhithamGreenNaghdiGPU(param;kwargs)\n\nGPU version of [`WhithamGreenNaghdiGPU`](@ref)\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.WhithamGreenNaghdiKlein","page":"Documentation","title":"ShallowWaterModels.WhithamGreenNaghdiKlein","text":"WhithamGreenNaghdi(params)\nThe modified Green-Naghdi model proposed by V. Duchêne, S. Israwi and R. Talhouk.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.WhithamGreenNaghdiSym","page":"Documentation","title":"ShallowWaterModels.WhithamGreenNaghdiSym","text":"WhithamGreenNaghdiSym(params)\nThe modified Green-Naghdi model proposed by V. Duchêne, S. Israwi and R. Talhouk.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.fdBoussinesq","page":"Documentation","title":"ShallowWaterModels.fdBoussinesq","text":"fdBoussinesq_1(params)\nparams must contain a parameter α.\nIf α = 1, then the model has been introduced and studied by E. Dinvay and collaborators.\nIf α = 1/2, then the model is a quasilinear version.\nIf α < 1/2, then expect instabilities stemming from ill-posedness of the model.\n\n\n\n\n\n","category":"type"},{"location":"#ShallowWaterModels.CnoidalWaveWhithamGreenNaghdi-Tuple{NamedTuple,Array{Float64,1}}","page":"Documentation","title":"ShallowWaterModels.CnoidalWaveWhithamGreenNaghdi","text":"`CnoidalWaveWhithamGreenNaghdi(mesh, param, guess; kwargs...)`\n\nComputes the Serre-Green-Naghdi cnoidal wave with prescribed h₀<h₁<h₂. h_1 is the minimum, h_2 is the maximum. As h₀ -> h₁, the cnoidal wave converges towards the solitary wave.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing h₀<h₁<h₂ and dimensionless parameters ϵ and μ, and number of collocation points N;\nguess :: Vector{Float64}: initial guess for the surface deformation.\n\nKeywords\n\nP :: Int: the number of periods of the cnoidal wave in the constructed mesh;\nSGN :: Bool: if true computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave;\nexact :: Bool: if true, uses the exact formula for SGN, either as the solution if SGN=true, or overrides the guess if  SGN=false\nmethod :: Int: equation used (between 1 and 4);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm;\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian (default is 0).\n\nReturn values\n\n(η,u,v,mesh,param) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: tangential velocity;\nmesh :: Vector{Float64} collocation points;\nparam :: NamedTuple: useful parameters\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.SolitaryWaveWhithamBoussinesq-Tuple{Mesh,NamedTuple,Array{Float64,1}}","page":"Documentation","title":"ShallowWaterModels.SolitaryWaveWhithamBoussinesq","text":"`SolitaryWaveWhithamBoussinesq(mesh, param, guess; kwargs...)`\n\nComputes the Whitham-Boussinesq solitary wave with prescribed velocity.\n\nArguments\n\nmesh :: Mesh: parameters of the numerical grid, e.g constructed through Mesh(L,N);\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ;\nguess :: Vector{Float64}: initial guess for the surface deformation.\n\nKeywords\n\nmodel :: Real: determines the model used (typically 1 or 1/2, default is 1);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm;\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian.\n\nReturn values\n\n(η,u) :: Tuple{Vector{Float64},Vector{Float64}} with\n\nη: surface deformation;\nu: velocity.\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple,Array{Float64,1}}","page":"Documentation","title":"ShallowWaterModels.SolitaryWaveWhithamGreenNaghdi","text":"`SolitaryWaveWhithamGreenNaghdi(param, guess; kwargs...)`\n\nComputes the Whitham-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\nguess :: Vector{Real}: initial guess for the surface deformation.\n\nKeywords\n\nSGN :: Bool: if true computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave;\nexact :: Bool: if true, overrides the guess with the exact formula for SGN (default is false);\nmethod :: Int: equation used (between 1 and 4);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false (default is false);\nverbose :: Bool: prints numerical errors at each step if true (default is false);\nmax_iter :: Int: maximum number of iterations of the Newton algorithm (default is 20);\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with u_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian (default is 0).\n\nReturn values\n\n(η,u,v) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: tangential velocity;\nmesh :: Vector{Float64} collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.Spectrum-Tuple{WhithamGreenNaghdi,Any,Any,Any,Any}","page":"Documentation","title":"ShallowWaterModels.Spectrum","text":"Spectrum(model,η,u,c,ν;kwargs)\n\nComputes the spectrum about a specified travelling solution of the the linearized Green-Naghdi model proposed by V. Duchêne, S. Israwi and R. Talhouk.\n\nArgument\n\nmodel should be of type WhithamGreenNaghdi,\n\nconstructed e.g. with `model = WhithamGreenNaghdi(param;SGN=true)` where\ne.g. `param = ( μ  = 0.1, ϵ  = 1, N  = 2^9, L  = 10*π)`\n\n(η,u) are real vectors of the aforementioned solution where\n\nwhere\n\n- `η` is the surface deformation;\n- `u` corresponds to the layer-averaged velocity.\n\n'c' is the velocity of the solution,\n'ν' is a Floquet coefficient.\n\nKeywords\n\nSGN :: Bool: if true computes the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (default is false);\n\nReturn values\n\nan Eigen factorization object L which contains the eigenvalues in L.values and the eigenvectors in the columns of the matrix L.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k]`.)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{Boussinesq,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(Boussinesq, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{CGBSW,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(CGBSW, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{CGBSW_naive,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(CGBSW_naive, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{Matsuno,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(Matsuno, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{Matsuno_mod_naive,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(Matsuno, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{Matsuno_naive,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(Matsuno, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{PseudoSpectral,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(PseudoSpectral, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{WaterWaves,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(WaterWaves, data)\nReconstructs physical variables from conformal variables\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{WhithamGreenNaghdi,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(WhithamGreenNaghdi, data)\n\ndata is of type Array{Complex{Float64},2}, e.g. last(p.data.U) where p is of type Problem.\n\nReturns (η,v,u), where\n\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nu corresponds to the layer-averaged velocity.\n\nInverse Fourier transform and real part, plus solving the elliptic problem for u.\n\nSee documentation of WhithamGreenNaghdi for more details.\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{WhithamGreenNaghdiGPU,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(WhithamGreenNaghdi, data)\n\ndata is of type Array{Complex{Float64},2}, e.g. last(p.data.U) where p is of type Problem.\n\nReturns (η,v,u), where\n\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nu corresponds to the layer-averaged velocity.\n\nInverse Fourier transform and real part, plus solving the elliptic problem for u.\n\nSee documentation of WhithamGreenNaghdi for more details.\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{WhithamGreenNaghdiKlein,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(WhithamGreenNaghdi, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{WhithamGreenNaghdiSym,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(WhithamGreenNaghdiSym, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapfro-Tuple{fdBoussinesq,Array{Complex{Float64},2}}","page":"Documentation","title":"ShallowWaterModels.mapfro","text":"mapfro(fdBoussinesq, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{Boussinesq,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(Boussinesq, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{CGBSW,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(CGBSW, data)\nthe velocity should be zero\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{CGBSW_naive,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(CGBSW_naive, data)\nthe velocity should be zero\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{Matsuno,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(Matsuno, data)\nthe velocity should be zero\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{Matsuno_mod_naive,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(Matsuno, data)\nthe velocity should be zero\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{Matsuno_naive,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(Matsuno, data)\nthe velocity should be zero\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{PseudoSpectral,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(PseudoSpectral, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{WaterWaves,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(WaterWaves, data)\nConstructs conformal variables in the flat strip\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{WhithamGreenNaghdi,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(WhithamGreenNaghdi, data)\n\ndata is of type InitialData, maybe constructed by Init(...).\n\nPerforms a discrete Fourier transform with, possibly, dealiasing and Krasny filter.\n\nSee documentation of WhithamGreenNaghdi for more details.\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{WhithamGreenNaghdiGPU,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(WhithamGreenNaghdi, data)\n\ndata is of type InitialData, maybe constructed by Init(...).\n\nPerforms a discrete Fourier transform with, possibly, dealiasing and Krasny filter.\n\nSee documentation of WhithamGreenNaghdi for more details.\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{WhithamGreenNaghdiKlein,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(WhithamGreenNaghdiKlein, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{WhithamGreenNaghdiSym,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(WhithamGreenNaghdiSym, data)\n\n\n\n\n\n","category":"method"},{"location":"#ShallowWaterModels.mapto-Tuple{fdBoussinesq,InitialData}","page":"Documentation","title":"ShallowWaterModels.mapto","text":"mapto(fdBoussinesq, data)\n\n\n\n\n\n","category":"method"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"EditURL = \"https://github.com/WaterWavesModels/ShallowWaterModels.jl/blob/master/examples/animation.jl\"","category":"page"},{"location":"examples/animation/#Animation-1","page":"Animation","title":"Animation","text":"","category":"section"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"shallow water problem solved with Boussinesq-Whitham model animation","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"#using ShallowWaterModels\ninclude(\"../src/dependencies.jl\")","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"param = ( μ  = 1/20,\n          ϵ  = 1/2,\n          N  = 2^11,\n          L  = 10,\n          T  = 8.0,\n          dt = 0.001,\n          α  = 1,\n          θ  = 2)\n\ninitial = Bellcurve(param)\nsolver  = RK4(param)\nmodel   = fdBoussinesq(param)\nproblem = Problem( model, initial, param )","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"print(\"\\nNow solving the model \",problem.model.label,\"\\n\")\n@time solve!( problem )","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"print(\"\\nNow generating the animation\\n\")\n@time create_animation( problem )","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"(Image: )","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"","category":"page"},{"location":"examples/animation/#","page":"Animation","title":"Animation","text":"This page was generated using Literate.jl.","category":"page"}]
}
